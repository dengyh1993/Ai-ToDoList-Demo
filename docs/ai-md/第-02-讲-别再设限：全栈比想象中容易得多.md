大家好，我是拭心。

读完上一讲 《[第 01 讲 | 职业全景：为什么要转型 AI 应用工程师，这个岗位需要什么能力？》](https://xiaobot.net/post/8e8e0693-00a0-4220-bf3e-dec50a17294d)，我们知道：**要成为 AI 应用工程师，首先需要成为全栈工程师。**

这一讲我们来聊聊 AI 时代如何开发全栈应用。

## 一、LLM 是水电煤，工程才是最后一公里

很多人对 AI 应用开发有个误解：觉得只要会调用大模型 API，就能做 AI 产品了。

这就像是说"只要会用电，就能造出电视机"一样荒谬。

## 大模型不是全部

事实上，**大模型（LLM）只是 AI 应用的一小部分**，它不能一下生成完整的 APP，也不能直接服务用户。

它能做的就是一个“文本生成器”，你给它输入一段文本，它输出另一段文本。仅此而已。

要把这个"文本生成器"变成一个真正有用的产品，我们还需要做这些：

-   前端界面的设计及实现：用户在哪里输入？结果怎么展示？
    
-   后端服务的设计及实现：如何处理并发请求？如何做用户鉴权？如何限流防刷？
    
-   数据存储：对话历史存哪里？用户数据怎么管理？
    
-   业务逻辑：如何把 AI 能力嵌入到实际业务流程中？
    
-   部署运维：怎么上线？怎么监控？怎么扩容？
    

这些问题，还得靠人去思考实现。

## 20% vs 80%

对于大部分 AI 应用（不需要训练模型），大模型和工程开发的工作量占比是二八开。

**模型层工作量占 20%，主要是：**

-   调用 OpenAI/DeepSeek 等 API
    
-   写 Prompt，调参数
    
-   处理返回结果
    

**工程层占 80%，主要是：**

-   如何设计用户交互流程？
    
-   如何处理 AI 返回的流式数据？
    
-   如何做错误处理和重试机制？
    
-   如何优化响应速度和成本？
    
-   如何设计数据库？
    
-   如何做用户权限管理？
    
-   如何部署到生产环境？
    
-   如何监控和优化性能？
    

**占比大的这部分，才是应用的护城河。**

## 真实案例：Lovart 如何用工程能力封神

Lovart 是一个 AI 设计工具，2025 年 5 月上线，上线 3 个月用户量就突破 200万，付费转化率高达 **15%**（这个数属于相当高）。

![](https://static.xiaobot.net/file/2025-12-12/21332/9bd8b8d35efb01f648976f55e45675a0.png!post)

转化率如此高，是因为它优秀的产品功能和用户体验。比如最近它推出的"文字编辑"功能，很多用户直呼“彻底替代了 PS”。

![](https://static.xiaobot.net/file/2025-12-12/21332/6290632d27813e1b3d2b8db2c8a65139.png!post)

> 图片来自 [https://mp.weixin.qq.com/s/yFKPEE9kWqU31Dqel52zjQ](https://mp.weixin.qq.com/s/yFKPEE9kWqU31Dqel52zjQ)

这个“文字编辑”功能主要分三步：

1.  自动提取图片中的所有文字
    
2.  用户修改文字内容
    
3.  AI 自动替换，保持原有样式和字体一致性
    

每一步背后都有着复杂的工程实现：

-   **结构化识图**：用多模态模型提取图片中的所有文字，精准定位每个文字的位置、样式、字体
    
-   **交互设计**：把识别结果变成可编辑的文本框，用户体验流畅
    
-   **原地替换**：用户修改后，调用 AI 模型在原位置精准替换，保持样式一致
    
-   **配套功能**：Touch Edit（指哪改哪）、Mock up（样机贴图）、多尺寸直出
    

能如此丝滑的解决 AI 生图的文字精细化处理需求，Nano Banana Pro （谷歌的图片模型）固然重要，但工程上的实现，才是这个功能的真正壁垒。

[这就是一个牛逼的模型，加上一个超级牛逼的应用，所带来的超级化学反应。](https://mp.weixin.qq.com/s/yFKPEE9kWqU31Dqel52zjQ)

如果 Lovart 团队只会调用 AI 模型，他们只能做出一个"输入图片，输出修改后图片"的简单工具。正因为他们有强大的工程能力——理解用户需求、设计交互流程、处理复杂场景（文字多、有遮挡、特殊样式）、优化响应速度——才能做出一个"让用户忘记工具存在"的产品。

**这就是工程能力的价值：把 AI 从"文本生成器"变成"用户离不开的产品"。**

**这种情况下，如果你只把自己定位为"前端"或"后端"，你实际上是在告诉 AI：'请在这个边界内取代我'。**

因为 AI 最擅长的，就是在单一领域内生成代码。

它可以写出完美的 React 组件，也可以写出高效的 SQL 查询。但它不会主动思考：

-   这个功能该用什么技术栈？
    
-   前后端怎么协作？
    
-   数据流怎么设计？
    
-   用户体验怎么优化？
    

**这些"连接"的能力，才是全栈工程师的核心价值。**

## 二、为什么 AI 时代的"全栈"变得如此廉价又如此昂贵？

AI Coding 出现以后，全栈开发正在经历一场矛盾的变革，两极差异非常明显：入门级别的全栈开发变得廉价、专业级别的全栈更加昂贵。

**廉价**，是因为技术门槛被彻底击穿了。AI 几秒钟就可以搞定一个 CRUD 接口 ；Prompt 一句话就能解决 CSS 样式问题；甚至都不用再背怎么配置 Nginx，复制粘贴 AI 生成的配置文件就行。那些曾经需要在 Stack Overflow 上搜索半天、在文档里翻来覆去的技术细节，现在只需要用自然语言描述一下需求就能得到答案。

**昂贵**，是因为能够独立把想法变成上线产品的能力，变得前所未有的重要。市场不缺会画页面、会写接口的人，缺的是能思考产品功能背后的技术方案、从 0 到 1 完成产品闭环的人。**当** [**41% 的全球代码已经是 AI 生成或 AI 辅助**](https://www.51cto.com/aigc/8057.html)**，技术本身不再是护城河，工程实践能力才是。**

## 你是不是也有这些恐惧？

很多前端开发者，一想到这些场景就头大：

-   配置数据库连接池，MySQL、PostgreSQL 傻傻分不清楚
    
-   写 SQL 查询语句，JOIN、GROUP BY 总是出错
    
-   部署服务器，Docker、Nginx、PM2 一堆概念搞不懂
    
-   处理并发请求，什么是连接池？什么是事务隔离级别？
    

而很多后端开发者，一看到这些就想放弃：

-   Flex 布局，为什么加了 \`justify-content\` 还是不居中？
    
-   React 状态管理，useState、useEffect、useContext 什么时候用？
    
-   CSS 动画，transition 和 animation 有什么区别？
    
-   响应式设计，媒体查询怎么写？移动端适配怎么做？
    

这些恐惧，本质上都是**认知边界**带来的心理障碍。你不是学不会，而是觉得"这不是我的领域"，于是给自己设了一道墙。

## 从"什么都会写"到"什么都敢用"

以前的全栈工程师，是那种"前端后端数据库运维都能写一点"的多面手。但说实话，这种人要么是天赋异禀，要么是花了十年时间慢慢积累。对于大多数人来说，这个门槛太高了。

而现在，全栈门槛大大降低，**现在的全栈工程师，本质是"什么都敢用"的工程师**。AI 是你的外挂大脑，补齐了你最害怕的那一半拼图。

-   你是前端？不懂数据库没关系，告诉 AI"我要一个用户表和订单表"，Schema 自动生成。
    
-   你是后端？不懂 CSS 没关系，告诉 AI"给我一个极简风的登录页，带磨砂玻璃效果"，React 组件马上就会生成。
    

数据不会骗人：76% 的专业开发者已经在使用AI 编码工具，其中全栈开发者的采用率最高，达到 32.5%。**这些人不是因为"全能"才成为全栈，而是因为敢于用 AI 突破边界，才成为全栈。**

![](https://static.xiaobot.net/file/2025-12-12/21332/3ccc1e2cdf13f78962871977785cb71b.png!post)

## 三、AI 如何帮你跨越"那道墙"

接下来，我们就来看看，AI 如何帮你跨越那道"前端/后端"的墙。

## 前端开发者的"后端恐惧症"：从配置地狱到一句话搞定

如果你是前端开发者，在没有 AI 之前，想做一个完整的项目，你需要：

1.  选择数据库：MySQL？PostgreSQL？MongoDB？各有什么优缺点？
    
2.  配置连接池：最大连接数设多少？超时时间怎么设？
    
3.  写 SQL 语句：JOIN 怎么写？索引怎么建？事务怎么处理？
    
4.  搭建后端服务：Spring？Express？Koa？Nest.js？路由怎么设计？
    
5.  处理并发：如何防止竞态条件？如何做限流？
    
6.  部署上线：Docker 怎么用？Nginx 怎么配？域名怎么解析？
    

每一步都是一个深坑，光是学习这些概念，就要花几个月时间。

而现在有了 AI，你只需要：

**Step 1：告诉 AI 你要什么**

```undefined
提示词：我要做一个待办事项应用，需要一个数据库来存储任务。每个任务包括：标题、描述、状态（待完成/已完成）、创建时间。
```

> 输入给 Cursor 这种 AI IDE 或者 豆包 这种对话智能体都可以。

**Step 2：AI 生成数据库 Schema**

如果你选择 **SQLite（**本地文件数据库，零配置），在提示词里加上“使用 SQLite”：

```undefined
提示词：我要做一个待办事项应用，需要一个数据库来存储任务。每个任务包括：标题、描述、状态（待完成/已完成）、创建时间。使用 SQLite。
```

AI 就会输出这样的语句并执行：

```pgsql
CREATE TABLE tasks (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'pending',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

如果你选择 **Supabase**（云端数据库，自带 API）做数据库，只需要告诉 AI："用 Supabase "：

```undefined
提示词：我要做一个待办事项应用，需要一个数据库来存储任务。每个任务包括：标题、描述、状态（待完成/已完成）、创建时间。使用 Supabase。
```

然后打开 Supabase 控制台：[https://supabase.com/dashboard/organizations](https://supabase.com/dashboard/organizations)，复制粘贴 AI 生成的建表 SQL 到 Supabase SQL Editor，点击 Run，数据表就建好了。

![](https://static.xiaobot.net/file/2025-12-13/21332/65e04f081e6f28e04168ce2798b474d8.png!post)![](https://static.xiaobot.net/file/2025-12-13/21332/416fd29c44b91603b88c28e5e8175f3c.png!post)

> 接下来我们数据库就用 Supabase ，因为它是目前做独立应用和出海应用比较流行的后端方案，熟悉以后做自己的项目也用的到。

**Step 3：AI 生成后端接口**

有了 Supabase 表以后，接下来使用它提供的 api 就可以很容易的封装接口。

只需要告诉 AI “使用 supabase-js 生成相关的增删改查接口”，AI 就会把接口代码创建好，结果会是类似这样的代码：

```sas
import { createClient } from '@supabase/supabase-js'
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_KEY
)
export default async function handler(req, res) {
  if (req.method === 'GET') {
    const { data, error } = await supabase
      .from('tasks')
      .select('*')
      .order('created_at', { ascending: false })
    if (error) return res.status(500).json({ error: error.message })
    return res.status(200).json(data)
  }
  if (req.method === 'POST') {
    const { title, description } = req.body
    const { data, error } = await supabase
      .from('tasks')
      .insert([{ title, description }])
    if (error) return res.status(500).json({ error: error.message })
    return res.status(201).json(data)
  }
}
```

这段代码，你先简单感受下它是如何实现一个接口的，稍后我们会通过一个具体的案例详细介绍。

### 效率对比：从 3 天到 10 分钟

上面的这个简单示例，目的是告诉前端开发者们，如今开发接口方便太多了。

-   **传统方式需要**：学习数据库 → 学习 SQL → 学习后端框架 → 写代码 → 调试 → 部署（3 天起步）
    
-   **而 现在 AI 辅助下**：描述需求 → AI 生成代码 → 复制粘贴 → 测试（10 分钟搞定）
    

**你以为的门槛，在 AI 面前只是一个 Prompt 的距离。**

## 后端开发者的"样式恐惧症"：从像素对齐到一键生成

如果你是后端开发者，在 AI 出来前想做一个好看的界面，你需要：

1.  学习 CSS 布局：Flex？Grid？为什么加了 \`justify-content: center\` 还是不居中？
    
2.  调整样式：间距、颜色、字体、圆角、阴影……每个属性都要查文档
    
3.  响应式设计：媒体查询怎么写？移动端适配怎么做？
    
4.  处理兼容性：Chrome 正常，Safari 就错位了？
    
5.  学习前端框架：React？Vue？组件怎么写？状态怎么管理？
    

每次调样式都是一场噩梦，改了这里，那里又错了。

而现在，你只需要：

**Step 1：告诉 AI 你要什么样的界面（最好配上参考图)**

```asciidoc
提示词：给我一个极简风格的待办事项页面：
- 顶部是标题和添加按钮
- 中间是任务列表，每个任务有复选框、标题、删除按钮
- 使用磨砂玻璃效果，配色用浅蓝色系
- 支持移动端适配
```

**Step 2：AI 生成完整组件**

使用 [v0（Vercel 出品的 AI UI 生成工具，打不开就用梯子）](https://v0.app/)：

-   输入上面的描述
    
-   几秒钟后，生成完整的 React + Tailwind CSS 组件
    
-   可以直接预览效果，不满意就继续调整 Prompt
    

![](https://static.xiaobot.net/file/2025-12-13/21332/c50268316dd1b003e6595b4e30bca248.png!post)

或者使用 Cursor，把上面的提示词发给它，就会生成类似这样的项目代码：

```javascript
import { useState } from 'react'
export default function TodoList() {
  const [tasks, setTasks] = useState([])
  const [input, setInput] = useState('')
  const addTask = () => {
    if (input.trim()) {
      setTasks([...tasks, { id: Date.now(), title: input, done: false }])
      setInput('')
    }
  }
  const toggleTask = (id) => {
    setTasks(tasks.map(task => 
      task.id === id ? { ...task, done: !task.done } : task
    ))
  }
  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-blue-100 p-8">
      <div className="max-w-2xl mx-auto bg-white/80 backdrop-blur-lg rounded-2xl shadow-xl p-6">
        <h1 className="text-3xl font-bold text-gray-800 mb-6">我的待办</h1>
        <div className="flex gap-2 mb-6">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyPress={(e) => e.key === 'Enter' && addTask()}
            placeholder="添加新任务..."
            className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          />
          <button
            onClick={addTask}
            className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition"
          >
            添加
          </button>
        </div>
        <div className="space-y-2">
          {tasks.map(task => (
            <div key={task.id} className="flex items-center gap-3 p-3 bg-white rounded-lg shadow-sm">
              <input
                type="checkbox"
                checked={task.done}
                onChange={() => toggleTask(task.id)}
                className="w-5 h-5"
              />
              <span className={`flex-1 ${task.done ? 'line-through text-gray-400' : 'text-gray-800'}`}>
                {task.title}
              </span>
              <button
                onClick={() => setTasks(tasks.filter(t => t.id !== task.id))}
                className="text-red-500 hover:text-red-700"
              >
                删除
              </button>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

这段代码，包含了：

-   React Hooks（useState）
    
-   Tailwind CSS 样式（渐变背景、磨砂玻璃、响应式布局）
    
-   交互逻辑（添加、完成、删除）
    

你不需要理解每个 CSS 类的含义，也不需要管什么是 React Hooks，想要调整只需要告诉 AI："把背景改成紫色"、"把按钮变大一点"，AI 就能精准修改。

甚至在 Cursor 的最新版本里，我们可以直接在界面上手动调整不喜欢的地方，不用修改 CSS、不用和 AI 沟通，像低代码一样调整属性即可。朋友们，现在修改 UI 比你想得容易了很多。

![](https://static.xiaobot.net/file/2025-12-13/21332/d8c58d4baab8c6e1b0b7d6bf648a8539.jpeg!post)

> 对 Cursor 这个功能感兴趣的朋友请看[《Visual Editor for Cursor Browser》](https://mp.weixin.qq.com/s/IP_2E8ze8bd0aBZUM9HKWQ)。

**效率对比：从 2 天到 10 分钟**

通过上面这个简单示例，我们可以看到，即使完全不懂 HTML CSS 也能开发前端页面样式。

-   传统方式你需要这样：学习 CSS → 学习 React → 写组件 → 调样式 → 适配移动端（2 天起步）
    
-   而现在：描述需求 → AI 生成组件 → 微调样式（10 分钟搞定）
    

**代码只是表达逻辑的一种方言，现在我们有了普通话（自然语言），为什么还要被方言限制住？**

## 四、微全栈实战：10 分钟上线一个"AI 待办清单"

通过前面的例子，我们可以知道，靠嘴开发前后端不再是段子，接下来我们通过一个完整案例体会一下整个流程，体验"一人成军"的快感。

## 项目简介：一个有 AI 能力的 Todo List

我们要开发的是一个有 AI 能力的待办事项列表，AI 在其中的作用是帮助我们拆解任务。

很多时候，一件事迟迟不做、非得拖延到最后一刻才开始，是因为我们不知道如何下手，行动力被不确定性阻断，**通过 AI 把要做的事情拆解为具体的、可执行的小事，就可以大大提升执行效率**。

![](https://static.xiaobot.net/file/2025-12-13/21332/faaff25247e001463a9c8fba72976da2.png!post)

项目完整代码见 [https://github.com/shixinzhang/AI-TODO](https://github.com/shixinzhang/AI-TODO)，最终效果如上图所示。

**核心功能**：

-   基础功能：添加、完成、删除任务
    
-   AI 能力：输入一个宽泛任务（如"准备下周的产品发布"），AI 自动拆解成 3-5 个可执行的小步骤
    

**技术栈**（专门为降低门槛设计）：

-   前端：React + Tailwind CSS（AI 写 UI）
    
-   后端：Next.js API Routes（AI 写逻辑）
    
-   数据库：Supabase（云端，零配置）
    
-   AI 能力：代理 OpenAI API
    

开发工具建议使用 Cursor 或者 [https://antigravity.google/](https://antigravity.google/)，用 TRAE 的话建议 TRAE 国际版，模型优先用 Gemini 和 Claude。

## Step 1：数据库设计

**第一个提示词：设计数据库表结构**

```asciidoc
我要做一个待办事项应用，需要设计一个 tasks 表。
每个任务包括：
- id（主键）
- title（任务标题）
- description（任务描述，可选）
- status（状态：pending 或 completed）
- parent_id（父任务 ID，用于关联 AI 拆解的子任务）
- created_at（创建时间）
请帮我生成 Supabase 的建表 SQL。
```

**AI 生成的 SQL：**

```pgsql
CREATE TABLE tasks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title TEXT NOT NULL,
  description TEXT,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'completed')),
  parent_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
-- 创建索引，优化查询性能
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_parent_id ON tasks(parent_id);
```

**建表操作步骤（截图请参考前面相似部分）：**

1\. 打开 [Supabase 控制台（https://supabase.com）](https://supabase.com/dashboard/org)

2\. 创建一个新项目（免费额度足够测试）

3\. 进入 SQL Editor

4\. 复制粘贴上面的 SQL，点击运行

5\. 数据库就绪！点击侧边栏的 Database 预览表结构

![](https://static.xiaobot.net/file/2025-12-13/21332/899248638349eef9a5367d674fb82c5f.png!post)

你不需要理解 UUID、TIMESTAMPTZ、CHECK 约束是什么，AI 已经帮你考虑了数据类型、约束条件、索引优化。

## Step 2：后端 API 开发

**第二个提示词：生成 CRUD 接口**

```bash
使用 Next.js API Routes 和 Supabase，帮我实现以下接口：
1. GET /api/tasks - 获取所有任务（按创建时间倒序）
2. POST /api/tasks - 创建新任务
3. PATCH /api/tasks/[id] - 更新任务状态
4. DELETE /api/tasks/[id] - 删除任务
请包含错误处理和类型检查。
```

提示词输入给 Cursor/Claude Code/Antigravity/TRAE 任意一个即可，AI 一般会做这些事：

![](https://static.xiaobot.net/file/2025-12-13/21332/cfcc3a7ef3cfac0bfaac0d5127e49fc8.png!post)

> 如果你还没用过 AI IDE，我建议使用 Cursor/Antigravity，如果不会配置或者不想多花钱，可以使用 TRAE。

AI 生成代码后，我们可以一边告诉它“启动项目”，另一方面 review 生成的代码。

虽然 AI 强大，但我们还是要**带着怀疑的态度去看它的生成结果，做到核心逻辑心中有数**。这样哪怕项目越变越大，我们还能把控的住，不至于到后期出了问题无法定位、AI 改错了逻辑没有及时发现。

> 项目已上传到 Github：[https://github.com/shixinzhang/AI-TODO](https://github.com/shixinzhang/AI-TODO)

**AI 生成的代码 review 及补充配置信息**

代码 review 也有重点，我的习惯是：

1.  先看依赖库
    
2.  然后看类型定义字段是否完整
    
3.  然后看接口是否齐全、是否有日志、异常处理是否完善
    
4.  然后看配置有没有写死，有什么信息需要改成灵活配置
    

首先看下 package.json 确认核心依赖是否添加：

![](https://static.xiaobot.net/file/2025-12-13/21332/d4387ff50c8436ba6e85d27a01e43b74.png!post)

然后看下定义的类型是否正确：

```none
//文件： types/task.ts
export interface Task {
  id: string
  title: string
  completed: boolean
  priority: 'low' | 'medium' | 'high'
  due_date: string | null
  created_at: string
  updated_at: string
}
export interface CreateTaskRequest {
  title: string
  priority?: 'low' | 'medium' | 'high'
  due_date?: string | null
}
export interface UpdateTaskRequest {
  completed?: boolean
  title?: string
  priority?: 'low' | 'medium' | 'high'
  due_date?: string | null
}
export interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: string
}
```

**类型文件是功能的根本，如果类型文件里少了字段，那逻辑里必然会缺失，所以首先要检查这里。**

然后看下接口文件 pages/api/tasks/index.ts :

![](https://static.xiaobot.net/file/2025-12-13/21332/df6fe74433540b941d9cc87188495bc2.png!post)

Review 接口主要注意这些：

1.  越权：用户 A 能不能删 B 的任务（没验数据全县）
    
2.  数据泄露：返回结果是否暴露了密码等敏感字段
    
3.  错误处理：异常 case 里有没有返回友好、明确的错误信息
    

AI 生成的增删改查常漏这些，能跑但埋雷。

接口检查完后，接着就是填写配置，启动项目。

使用 Supabase 我们需要提供两个配置（项目 url 和 key）：

```none
# Supabase 配置
NEXT_PUBLIC_SUPABASE_URL=your_supabase_project_url
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key
```

通过项目面板的 Project Settings 里可以获取：

![](https://static.xiaobot.net/file/2025-12-13/21332/22c14c28ba30d9104df2e185c5130096.png!post)![](https://static.xiaobot.net/file/2025-12-13/21332/613b72a52896df99a63ee951fc7d0ae8.png!post)

项目 url 在 Data API 里，点击上图所示的 Copy 按钮即可复制。

![](https://static.xiaobot.net/file/2025-12-13/21332/3cb5423f1a75595d99d8fa34915fedf3.png!post)

而 key 在 API Keys 里，点击上图的按钮复制。

复制这两个配置到 .env.local 中后，就可以让 AI 启动项目了。

如果要手动执行，需要先执行 npm init 安装依赖，然后执行 npm dev 启动项目。

> 启动过程遇到报错，直接复制粘贴让 AI 解决。

项目启动后，让 AI 生成**所有接口**的测试脚本并执行。

记住是「所有接口」，**测试覆盖不到的代码，就是埋雷的代码。**

我这边 AI 会生成这样的脚本：

![](https://static.xiaobot.net/file/2025-12-13/21332/cd9864bd1a8da3609922695bea0c727e.png!post)

> 测试脚本在这里：[https://github.com/shixinzhang/AI-TODO/blob/main/test-api.sh](https://github.com/shixinzhang/AI-TODO/blob/main/test-api.sh)

**可能遇到的问题**

如果你跟着第三节创建过同名的表，你可能会遇到这样的报错：Could not find the 'completed' column of 'tasks' in the schema cache.

这说明这次 AI 生成的代码 model 和之前创建的表字段不一致，没关系，我们去 Supabase SQL Editor 中删除旧表就可以。

![](https://static.xiaobot.net/file/2025-12-13/21332/0f7941e8aabf9e5a9cddf8835624bfba.png!post)

如上图所示， Supabase 右上角有一个好用的功能「AI Assistant」，它可以让我们通过对话的方式执行 SQL。

比如现在要删除旧表，只需要在输入框打字即可。

![](https://static.xiaobot.net/file/2025-12-13/21332/e1f191a8b3f375ab7ad509090296467e.png!post)

Supabase AI Assistant 会告知我们风险，然后提供选项让我们是否确认执行：

![](https://static.xiaobot.net/file/2025-12-13/21332/b43cf846e98a523a9a78293a073c969c.png!post)

当我们输入 1 表示确认要执行后，就会生成删除语句，点一下「Run Query」就会执行：

![](https://static.xiaobot.net/file/2025-12-13/21332/633d4e7a1cf82f90bf6e11ecc0c8e6f7.png!post)![](https://static.xiaobot.net/file/2025-12-13/21332/2e7b7cd8ddf99af89898f0a1f660d5fe.png!post)

删除之后，手动在 SQL Editor 新建一个表（复制 [supabase-schema.sql](https://github.com/shixinzhang/AI-TODO/blob/main/supabase-schema.sql) 的内容），然后重新执行测试脚本：

![](https://static.xiaobot.net/file/2025-12-13/21332/f987f8e2a61f6183f172f65d924e5a08.png!post)

OK，这下任务的增删改查接口代码生成和测试就结束了。

从头到尾我们都没有讲 SQL 语法、代码规则，讲的是流程和经验。你不需要从零学习 Next.js 的路由规则、Supabase 的 API 用法，只需要让 AI 去做，然后去检查。

## Step 3：AI 能力集成

这是整个项目的**魔法时刻**——让 AI 自动拆解任务。

模型我们使用 DeekSeek，框架使用 [OpenAI 的 JS 库](https://www.npmjs.com/package/openai)，这个库提供了从 TypeScript 或JavaScript 请求 OpenAI REST API 的接口方法，同时也支持我们修改请求地址和模型。使用的时候需要提供两个配置信息：base url 和 api key。

由于 OpenAI 的特殊性（大陆不能直接请求），所以我们使用[代理接口 uiuiapi 聚会平台](https://sg.uiuiapi.com/register?aff=9ume) ，它的好处是注册后就有免费额度，并且使用起来很简单。

> 这个平台我目前仅在学习测试时使用，尚未大规模线上使用过。
> 
> 如果要在线上使用建议多考察研究下。

使用 UIUIAPI 平台后，base url 是：

```typescript
https://sg.uiuiapi.com/v1
```

而 API key 需要去 [UIUIAPI 后台（https://sg.uiuiapi.com/console/token）](https://sg.uiuiapi.com/console/token)创建：

![](https://static.xiaobot.net/file/2025-12-13/21332/992d58298e1c71447edbc60ee801ee13.png!post)

点击上图所示的「添加令牌」，在弹出的弹窗里填写基本信息，然后点击「密钥」右侧的按钮复制 key：

![](https://static.xiaobot.net/file/2025-12-13/21332/1ca0305aeb776682da1f4db3b1bcdaa8.png!post)

粘贴 key 到 .env.local（若没有请复制 .env.example 并改名） 中。

![](https://static.xiaobot.net/file/2025-12-13/21332/74837321ff2747cc61a3758bb06cfe48.png!post)

> NEXT\_PUBLIC\_API\_BASE\_URL 和 NEXT\_PUBLIC\_APP\_ID 不是必须的，没有也不影响。

配置完成后，接下来让 AI 生成 AI 调用代码。

**提示词 3：集成 AI 拆解功能**

```none
使用 OpenAI Node.js 库实现 /api/tasks/breakdown 接口，功能是：
1. 接收一个任务名
2. 调用 DeepSeek API（base url 是 https://sg.uiuiapi.com/v1， api key 的环境变量是 DEEPSEEK_API_KEY），让 AI 把这个任务拆解成 3-5 个可执行的小步骤
3. 把拆解后的子任务存入数据库，parent_id 设置为原任务 ID
4. 返回拆解结果
```

在上面的提示词里，我们指定了**接口名、要使用的库、模型和参数，并且确定了任务**，等待一段时间后，AI 就会生成接口。

**AI 生成的代码 review 和测试**

在我生成的项目里，这部分代码在 [pages/api/tasks/breakdown.ts](https://github.com/shixinzhang/AI-TODO/blob/main/pages/api/tasks/breakdown.ts) 文件中，我们来看下最核心的代码：

![](https://static.xiaobot.net/file/2025-12-13/21332/cfe39376afefac937d592a35303a2f61.png!post)

可以看到，AI 根据我们的需求做了这些事：

1.  生成了提示词
    
2.  规定了返回结构
    
3.  随后使用 openai 的库发起了调用，模型也是使用我们要求的
    
4.  最后还解析了返回结果
    

看着不错，接着我们可以让 AI 启动项目并生成测试脚本。

![](https://static.xiaobot.net/file/2025-12-13/21332/8e662b5072aec490da6d5a0a0ae707d3.png!post)

项目启动后，执行测试脚本，比如这样：

```none
curl -X POST "http://localhost:3000/api/tasks/breakdown" -H "Content-Type: application/json" -d '{"taskId": "8f36d56c-0709-4d20-bf7e-461b962100a8", "taskTitle": "完成一个待办事项应用开发"}' -s | jq '.'
```

顺利的话会返回这样的信息，证明接口调通：

![](https://static.xiaobot.net/file/2025-12-13/21332/db1323282e1632234aedbd8306e3ad1d.png!post)

如果调用失败（一般是返回结构解析失败），可以复制失败信息给 AI，它会自行修复。

到这里，我们这个项目最核心的接口部分就完成了。

**Review 这部分主要关注**：

-   Prompt 工程：提示词定义的 AI 的角色和输出格式
    
-   结果解析是否正常：把 AI 返回的文本按行拆分，去掉编号
    
-   错误处理：捕获 API 调用失败的情况
    

**Step 4：前端页面开发**

最后我们让 AI 实现前端页面。

**提示词 4：生成前端页面**

```none
在当前项目里创建前端页面，使用 React + Tailwind CSS，创建一个待办事项页面：
1. 顶部有输入框和"添加"按钮
2. 任务列表展示所有任务，每个任务有：
- 复选框（点击切换完成状态）
- 任务标题（已完成的显示删除线）
- "拆解"按钮（调用 AI 拆解任务）
- "删除"按钮
3. 子任务缩进显示，表示层级关系
4. 整体样式使用复古手账风格，有纸质纹理和模拟手写字体，每个任务前是手绘复选框，可用图钉或胶带装饰完成的任务。
请包含完整的状态管理和 API 调用逻辑。
```

提示词里之所以包含「在当前项目里创建」，是因为我们使用的框架是 Next.js，它可以**让我们把前后端写在一个项目里，一次性部署**。

Next.js 把 React 前端页面（.tsx）和 Node.js 后端接口（api/ 目录）放一起，共享同一份 TypeScript 类型。部署时，Vercel 会自动把前端静态资源发到 CDN，后端函数部署到边缘节点，不用我们操心。开发起来很方便，前端直接 import 后端函数，类型安全，也没有跨域问题。

Next.js 主要用在三个场景，**出海应用特别合适**：

1.  **内容型网站/Blog**：SEO 是刚需，Next.js 服务器渲染让 Google 能抓到完整内容，海外流量依赖搜索的场景必选。
    
2.  **SaaS/Web 应用**：登录后沉浸式交互用客户端渲染（CSR），营销页/文档页用服务器渲染（SSR），一套代码灵活切换，出海团队省成本。
    
3.  **电商业务**：页面秒开+SEO 双杀，日本 mercari、美国 Target 都在用。Vercel 全球 CDN 边缘部署，欧美用户访问延迟比国内服务器低 200ms+。
    

让 AI 执行提示词后，等待一段时间生成结束后，就可以看到结果。

> 由于我们使用的 AI IDE 和模型不同，运行可能会遇到一些细节问题未提及，只需要发给 AI 处理即可。

这个功能的前端代码比较简单，这里就不再贴代码了。日常 review AI 生成的前端代码主要关注功能完整性和性能。

## 完整功能演示及流程回顾

### **功能演示**

![](https://static.xiaobot.net/file/2025-12-13/21332/55cbd3bb79d967112df2da9b943144b7.png!post)

上图是项目启动后访问 [http://localhost:3000/](http://localhost:3000/) 的结果，因为我们的提示词里加了“复古手帐风格”，所以看起来还不错。

输入内容并点击添加后，会请求 [http://localhost:3000/api/tasks](http://localhost:3000/api/tasks) 接口：

![](https://static.xiaobot.net/file/2025-12-13/21332/7563d096aff16842012d94be86b528f8.png!post)

点击「拆解」后，会请求 [http://localhost:3000/api/tasks/breakdown](http://localhost:3000/api/tasks/breakdown) 接口，在其中会使用我们的提示词请求 deepseek 模型，等待模型返回后，展示出拆解后的步骤：

![](https://static.xiaobot.net/file/2025-12-13/21332/1f27777526b6b7c5258b1a6b3c2b71d3.png!post)![](https://static.xiaobot.net/file/2025-12-13/21332/f3f12d7772e944e96a0988157a607b25.png!post)

点击每个待办事项里的勾选框，会调用接口修改状态为完成。

### 流程回顾

OK，到这里我们这个微全栈项目就顺利完成了。我们来回顾一下整个流程：

-   首先数据库使用的 Supabase，通过 AI 可以生成 SQL，粘贴到其中执行一下就可以，要删除或者修改，也可以通过 Supabase 的 AI 助手完成
    
-   增删改查接口基于 Supabase 的 JS 库开发，只要告诉 AI 使用的是 Supabase
    
    -   为了方便 SEO 和前后端一起部署，我们使用了 Next.js 框架，因此在提示词里也要明确指出使用 Next.js
        
-   通过 OpenAI 的 JS 库 和 uiuiapi 代理接口实现了大模型拆解任务的能力
    
-   最后通过指定 UI 风格和 API 调用，让 AI 生成了比较美观、并且跑通接口调用的前端页面
    

## 通过这个项目你学到了什么？

通过这个的实战项目，你完成了：

-   数据库设计（[Supabase](https://supabase.com/)）
    
-   后端 API 开发（Next.js）
    
-   前端页面开发（[使用 v0 快速验证](https://v0.app/)，React + Tailwind）
    
-   AI 能力集成（通过 [uiuiapi 聚合平台](https://sg.uiuiapi.com/console)调用 DeepSeek API）
    
-   完整的产品闭环
    

你写了多少代码？ 几乎没有。你只是告诉 AI 你要什么，AI 帮你生成了所有代码。

虽然这些技术你还只停留在知道名词的阶段**，但你已经可以搭建出一个可以有效拆解任务、帮助拖延症患者提升行动力的产品，这就是 AI 时代最重要的能力。**

## 五、结语：你可以成为那个"超级个体"

如果你完整读到这里，我希望你已经感受到了一种可能性：**在 AI 时代，一个人就可以交付有价值的产品**。

## Sam Altman 的预言正在成为现实

OpenAI CEO Sam Altman 曾说过："**第一个 10 亿美元的独立创业公司将由一个人用一台笔记本电脑构建。**"

这不是科幻，而是正在发生的现实。

2025 年，我们已经看到：

-   独立开发者用 AI 工具 3 个月实现月收入 2 万元
    
-   15 人团队 90 天创造 1750 万美元 ARR
    
-   全球 41% 的代码是 AI 生成或 AI 辅助
    

**技术门槛正在消失，但产品能力的稀缺性正在上升。**

## 不要再给自己贴标签

如果你还在说"我是前端，不懂后端"，或者"我是后端，不会写 UI"，你实际上是在主动放弃这个时代最大的红利。

**AI 不会取代工程师，但会用 AI 的工程师会取代不会用 AI 的工程师。**

更准确地说：**会用 AI 做全栈的工程师，会取代只会单一领域的工程师。**

因为市场需要的不是"会写 React 的人"或"会写 SQL 的人"，而是"能把想法变成产品的人"。

## 从现在开始行动

这一讲的所有代码、提示词，都是我挨个测试过、真实有效的。你可以：

**1\. 现在就去试着跑起来：**

-   注册 Supabase 账号（免费）
    
-   注册 UIUI API 账号（免费额度足够测试）
    
-   用 Cursor 或 Claude 生成代码
    
-   跑通整个流程
    

**2\. 感受"掌控全局"的力量：**

-   当你看到数据库表创建成功
    
-   当你看到 API 返回正确的数据
    
-   当你看到 AI 自动拆解任务
    
-   那种"我真的做出来了"的成就感，会让你上瘾
    

**3\. 不要停下来：**

-   试着加一个"任务优先级"功能
    
-   试着加一个"任务提醒"功能
    
-   试着部署到 Vercel（一键部署）
    
-   每多做一个功能，你就离"全栈"更近一步
    

## 但是，会用 AI 还不够

你可能会问：既然 AI 这么强，我只要会写 Prompt 就行了吗？

**答案是：远远不够。**

AI 可以帮你生成代码，但很多人会遇到这些问题：

-   同样的需求，为什么别人让 AI 生成的代码一次就能跑通，你的却要改好几遍？
    
-   AI 生成的代码看起来没问题，但运行时总是报错，怎么快速定位问题？
    
-   如何让 AI 生成的代码更符合你的项目规范和代码风格？
    

这些问题的答案，都在下一讲《编程新范式：如何高效 Vibe Coding》中。

我会教你**如何让 AI 写代码更高效、更准确**，让你从"会用 AI"进化到"精通 AI 协作"。

请记住：**在 AI 时代，全栈工程师不是"什么都会一点"的平庸者，而是"什么都能搞定"的终结者。**

**你准备好成为那个"超级个体"了吗？**

**我们下一讲见。**

> 本专栏已开启「合伙人计划」，读者可生成专属的邀请链接或邀请海报。
> 
> 有人通过你的邀请链接或海报付费订阅时，会返现支付金额的 25% 给你，比如支付 298 元 会返现 74.5 元，快去分享给你的好朋友们吧！

转型 AI 工程师：重塑你的能力栈与思维

56 读者， 14 内容

![](https://xiaobot.net/img/icon_arrow_right_light.svg)